<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>貪食蛇遊戲</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');
        
        body {
            font-family: 'Noto Sans TC', sans-serif;
            touch-action: none; /* 防止手機滑動時觸發瀏覽器滾動 */
        }

        /* 遊戲畫布邊框發光效果 */
        #gameCanvas {
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.2);
        }

        /* 按鈕點擊效果 */
        .control-btn:active {
            transform: scale(0.95);
            background-color: rgba(74, 222, 128, 0.3);
        }
        
        /* 隱藏卷軸 */
        ::-webkit-scrollbar {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen flex flex-col items-center justify-center overflow-hidden">

    <!-- 標題與分數區 -->
    <div class="w-full max-w-md px-4 mb-2 flex justify-between items-end">
        <div>
            <h1 class="text-2xl font-bold text-green-400 tracking-wider">貪食蛇</h1>
            <p class="text-xs text-gray-400">電腦: 方向鍵 | 手機: 觸控按鈕</p>
        </div>
        <div class="text-right">
            <div class="text-sm text-gray-400">最高分數: <span id="highScore" class="text-white font-bold">0</span></div>
            <div class="text-xl">分數: <span id="score" class="text-green-400 font-bold">0</span></div>
        </div>
    </div>

    <!-- 遊戲區域 -->
    <div class="relative group">
        <canvas id="gameCanvas" width="400" height="400" class="bg-black rounded-lg border-2 border-gray-700 block max-w-[95vw] max-h-[60vh]"></canvas>
        
        <!-- 暫停/開始 覆蓋層 -->
        <div id="overlay" class="absolute inset-0 bg-black/80 flex flex-col items-center justify-center rounded-lg z-10">
            <h2 id="overlayTitle" class="text-3xl font-bold text-green-500 mb-4">準備開始</h2>
            <p id="overlaySub" class="text-gray-300 mb-6 text-center px-4">使用方向鍵或按鈕移動</p>
            <button id="startBtn" class="px-6 py-2 bg-green-600 hover:bg-green-500 text-white rounded-full font-bold transition shadow-lg border border-green-400">
                開始遊戲
            </button>
        </div>
    </div>

    <!-- 手機版控制區 (D-Pad) -->
    <div class="mt-4 grid grid-cols-3 gap-2 w-48 h-32 select-none md:hidden touch-manipulation">
        <div></div>
        <button id="btnUp" class="control-btn bg-gray-800 rounded-lg flex items-center justify-center border border-gray-700 text-green-400 active:bg-gray-700">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" />
            </svg>
        </button>
        <div></div>
        
        <button id="btnLeft" class="control-btn bg-gray-800 rounded-lg flex items-center justify-center border border-gray-700 text-green-400 active:bg-gray-700">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
            </svg>
        </button>
        <button id="btnDown" class="control-btn bg-gray-800 rounded-lg flex items-center justify-center border border-gray-700 text-green-400 active:bg-gray-700">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
            </svg>
        </button>
        <button id="btnRight" class="control-btn bg-gray-800 rounded-lg flex items-center justify-center border border-gray-700 text-green-400 active:bg-gray-700">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
        </button>
    </div>

    <!-- 電腦版提示文字 -->
    <div class="hidden md:block mt-4 text-gray-500 text-sm">
        按 <span class="bg-gray-800 px-1 rounded border border-gray-600">Space</span> 暫停/繼續
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const overlay = document.getElementById('overlay');
        const overlayTitle = document.getElementById('overlayTitle');
        const overlaySub = document.getElementById('overlaySub');
        const startBtn = document.getElementById('startBtn');

        // 遊戲參數
        const tileCount = 20; // 格子數量 (20x20)
        let gridSize = canvas.width / tileCount; // 每格大小
        
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        highScoreElement.innerText = highScore;

        let velocity = { x: 0, y: 0 };
        let trail = [];
        let tail = 5;
        let player = { x: 10, y: 10 };
        let food = { x: 15, y: 15 };
        
        let isGameRunning = false;
        let isPaused = false;
        let gameInterval;
        let lastInputDirection = { x: 0, y: 0 }; // 防止單一幀內快速按兩次導致自殺

        // 初始化
        function resetGame() {
            player = { x: 10, y: 10 };
            trail = [];
            tail = 5;
            velocity = { x: 1, y: 0 }; // 初始向右移動
            lastInputDirection = { x: 1, y: 0 };
            score = 0;
            scoreElement.innerText = score;
            placeFood();
        }

        function startGame() {
            resetGame();
            isGameRunning = true;
            isPaused = false;
            overlay.classList.add('hidden');
            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(gameLoop, 1000 / 5); 
        }

        function togglePause() {
            if (!isGameRunning) return;
            isPaused = !isPaused;
            if (isPaused) {
                overlayTitle.innerText = "已暫停";
                overlaySub.innerText = "點擊按鈕繼續遊戲";
                startBtn.innerText = "繼續";
                overlay.classList.remove('hidden');
                clearInterval(gameInterval);
            } else {
                overlay.classList.add('hidden');
                gameInterval = setInterval(gameLoop, 1000 / 5);
            }
        }

        function gameOver() {
            isGameRunning = false;
            clearInterval(gameInterval);
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeHighScore', highScore);
                highScoreElement.innerText = highScore;
            }

            overlayTitle.innerText = "遊戲結束";
            overlaySub.innerText = `最終分數: ${score}`;
            startBtn.innerText = "再玩一次";
            overlay.classList.remove('hidden');
        }

        function gameLoop() {
            player.x += velocity.x;
            player.y += velocity.y;

            // 穿牆機制 (碰到牆壁會從另一邊出來)
            // 如果想要撞牆死，可以把這裡改成 gameOver() 判斷
            if (player.x < 0) {
                // player.x = tileCount - 1; 
                gameOver(); return; // 撞牆死模式
            }
            if (player.x > tileCount - 1) {
                // player.x = 0;
                gameOver(); return; // 撞牆死模式
            }
            if (player.y < 0) {
                // player.y = tileCount - 1;
                gameOver(); return; // 撞牆死模式
            }
            if (player.y > tileCount - 1) {
                // player.y = 0;
                gameOver(); return; // 撞牆死模式
            }

            // 繪製背景
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 繪製蛇
            for (let i = 0; i < trail.length; i++) {
                // 蛇頭顏色略不同
                if (i === trail.length - 1) {
                    ctx.fillStyle = '#4ade80'; // 亮綠
                } else {
                    ctx.fillStyle = '#22c55e'; // 綠色
                }

                // 繪製蛇身，留一點空隙製造格子感
                ctx.fillRect(trail[i].x * gridSize, trail[i].y * gridSize, gridSize - 2, gridSize - 2);

                // 檢查是否撞到自己
                if (trail[i].x === player.x && trail[i].y === player.y) {
                    gameOver();
                    return;
                }
            }

            trail.push({ x: player.x, y: player.y });
            while (trail.length > tail) {
                trail.shift();
            }

            // 繪製食物
            ctx.fillStyle = '#ef4444'; // 紅色
            // 讓食物圓潤一點
            ctx.beginPath();
            let foodRadius = (gridSize - 2) / 2;
            let foodX = food.x * gridSize + gridSize / 2;
            let foodY = food.y * gridSize + gridSize / 2;
            ctx.arc(foodX, foodY, foodRadius, 0, 2 * Math.PI);
            ctx.fill();

            // 檢查吃到食物
            if (player.x === food.x && player.y === food.y) {
                tail++;
                score += 10;
                scoreElement.innerText = score;
                placeFood();
            }
            
            // 更新最後輸入方向，用於防止快速按鍵導致的自殺
            lastInputDirection = { ...velocity };
        }

        function placeFood() {
            // 避免食物生成在蛇身上
            let valid = false;
            while (!valid) {
                food.x = Math.floor(Math.random() * tileCount);
                food.y = Math.floor(Math.random() * tileCount);
                
                valid = true;
                for (let part of trail) {
                    if (part.x === food.x && part.y === food.y) {
                        valid = false;
                        break;
                    }
                }
            }
        }

        // 處理方向輸入
        function changeDirection(x, y) {
            if (!isGameRunning || isPaused) return;
            
            // 防止 180 度掉頭 (例如正在往右，不能直接往左)
            // 使用 lastInputDirection 而不是 current velocity 確保快速按鍵安全
            if (lastInputDirection.x !== 0 && x !== 0) return; // 水平移動中不能水平轉向
            if (lastInputDirection.y !== 0 && y !== 0) return; // 垂直移動中不能垂直轉向

            velocity = { x: x, y: y };
        }

        // 鍵盤控制
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowLeft':
                    changeDirection(-1, 0);
                    break;
                case 'ArrowUp':
                    changeDirection(0, -1);
                    break;
                case 'ArrowRight':
                    changeDirection(1, 0);
                    break;
                case 'ArrowDown':
                    changeDirection(0, 1);
                    break;
                case ' ':
                    if (!isGameRunning && overlay.classList.contains('hidden')) {
                        // 遊戲中按下空白鍵
                        togglePause();
                    } else if (!isGameRunning) {
                        // 開始畫面
                        startGame();
                    } else {
                        togglePause();
                    }
                    break;
            }
        });

        // 虛擬按鈕控制
        const btnUp = document.getElementById('btnUp');
        const btnDown = document.getElementById('btnDown');
        const btnLeft = document.getElementById('btnLeft');
        const btnRight = document.getElementById('btnRight');

        // 使用 touchstart 以獲得更快的反應速度，避免 300ms 延遲
        const addTouchHandler = (elem, x, y) => {
            elem.addEventListener('touchstart', (e) => {
                e.preventDefault(); // 防止雙擊縮放等默認行為
                changeDirection(x, y);
            }, { passive: false });
            
            // 為了在電腦上測試也可以用滑鼠點
            elem.addEventListener('click', () => changeDirection(x, y));
        };

        addTouchHandler(btnUp, 0, -1);
        addTouchHandler(btnDown, 0, 1);
        addTouchHandler(btnLeft, -1, 0);
        addTouchHandler(btnRight, 1, 0);

        // 開始按鈕
        startBtn.addEventListener('click', () => {
            if (isPaused) {
                togglePause();
            } else {
                startGame();
            }
        });

        // 視窗大小調整時重新計算格子大小 (雖然Canvas大小固定，但為了可能的擴展性)
        window.addEventListener('resize', () => {
            // 目前 Canvas 採用 CSS 固定比例縮放，邏輯無需變更
        });

    </script>
</body>
</html>