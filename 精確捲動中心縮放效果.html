<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>精確捲動中心縮放效果</title>

    <style>
        /* 基礎樣式：讓頁面可以捲動 */
        body { 
            margin: 0; 
            background-color: #f4f4f4; 
            min-height: 300vh; /* 確保有足夠的捲動空間 */
        }
        .placeholder { 
            height: 50vh; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            font-size: 2em; 
            color: #333; 
            background-color: #eee;
            margin-bottom: 50px;
        }

        /* 圖片容器樣式 */
        .image-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 60vh; /* 讓圖片有足夠的空間在視窗中移動 */
            margin: 50px 0;
        }

        /* 圖片基礎樣式 */
        .scroll-img {
            display: block; 
            width: 300px;
            height: 200px;
            object-fit: cover;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            will-change: transform; /* 提升動畫效能 */
            
            /* 初始狀態為略微縮小 */
            transform: scale(0.9);
            
            /* 移除 transition，因為縮放值由 JavaScript 連續計算 */
        }
    </style>
</head>
<body>

    <div class="placeholder">請捲動頁面</div>

    <div class="image-container">
        <img class="scroll-img" src="https://picsum.photos/id/433/300/200" alt="圖片 A">
    </div>
    
    <div class="image-container">
        <img class="scroll-img" src="https://picsum.photos/id/450/300/200" alt="圖片 B">
    </div>

    <div class="placeholder">繼續捲動</div>

    <div class="image-container">
        <img class="scroll-img" src="https://picsum.photos/id/470/300/200" alt="圖片 C">
    </div>

    <div class="image-container">
        <img class="scroll-img" src="https://picsum.photos/id/480/300/200" alt="圖片 D">
    </div>

    <div class="placeholder">頁面底部</div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const images = document.querySelectorAll('.scroll-img');
            let isTicking = false;
            
            // --- 設定動畫參數 ---
            const MAX_SCALE = 1.3; // 最大放大倍率（在中心時）
            const MIN_SCALE = 0.8; // 最小縮小倍率（離中心最遠時）
            const RANGE = window.innerHeight * 0.5; // 影響範圍（例如：從中心到視窗邊緣一半的距離）
            // --------------------

            /**
             * 將範圍內的值，從一個區間映射到另一個區間
             * @param {number} value 當前值
             * @param {number} inMin 輸入最小值
             * @param {number} inMax 輸入最大值
             * @param {number} outMin 輸出最小值
             * @param {number} outMax 輸出最大值
             * @returns {number} 映射後的值
             */
            const mapRange = (value, inMin, inMax, outMin, outMax) => {
                // 確保值在輸入區間內
                value = Math.max(inMin, Math.min(inMax, value));
                
                // 執行映射計算：(value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
                return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
            };

            /**
             * 根據元素中心與視窗中心的距離計算縮放值
             */
            const updateScale = () => {
                // 視窗中心Y座標
                const viewportCenterY = window.innerHeight / 2;

                images.forEach(img => {
                    // 取得圖片元素相對於視窗的位置資訊
                    const rect = img.getBoundingClientRect();
                    
                    // 圖片中心的Y座標
                    const elementCenterY = rect.top + rect.height / 2;

                    // 計算圖片中心與視窗中心的距離 (絕對值)
                    // 距離越小 (接近中心) 越接近 0
                    const distance = Math.abs(elementCenterY - viewportCenterY);

                    // ----------------------------------------------------
                    // 1. 計算縮放值 (Scale)
                    // ----------------------------------------------------
                    
                    // 距離在 [0, RANGE] 之間時才進行縮放計算
                    let scaleValue;
                    
                    if (distance <= RANGE) {
                        // 距離為 0 (中心) 時，scale = MAX_SCALE
                        // 距離為 RANGE 時，scale = MIN_SCALE
                        
                        // 將 distance (0 到 RANGE) 映射到 scale 值 (MAX_SCALE 到 MIN_SCALE)
                        scaleValue = mapRange(distance, 0, RANGE, MAX_SCALE, MIN_SCALE);
                    } else {
                        // 距離超出影響範圍，保持最小縮放
                        scaleValue = MIN_SCALE;
                    }

                    // 應用變形
                    img.style.transform = `scale(${scaleValue})`;
                });
                
                isTicking = false;
            };

            /**
             * 捲動事件處理函式
             */
            const handleScroll = () => {
                if (!isTicking) {
                    // 使用 requestAnimationFrame 確保動畫在瀏覽器的繪製週期中執行，實現最平滑的效果
                    window.requestAnimationFrame(() => {
                        updateScale();
                    });
                    isTicking = true;
                }
            };
            
            // 監聽捲動事件和視窗大小變動事件
            window.addEventListener('scroll', handleScroll);
            window.addEventListener('resize', handleScroll); // 視窗大小改變也要重新計算

            // 初始執行一次，確保剛載入時圖片位置正確
            handleScroll();
        });
    </script>
</body>
</html>